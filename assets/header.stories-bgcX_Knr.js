import{u as P,g as B}from"./index-CIKxb094.js";import{w as H,e as U}from"./index-Z5tTm0QU.js";import{R as T}from"./index-SZDuJNPZ.js";import{j as g}from"./jsx-runtime-BjG_zV1W.js";import{n as A}from"./image-sdoTkIVG.js";import{L as j}from"./link-BciY0GSP.js";import{B as F}from"./button.ui-Dyp5MyY_.js";import{c as M}from"./cn-CytzSlOG.js";import"./image-context-Xl26mMgV.js";import"./add-base-path-Ca8sstGr.js";import"./index-CPocAcyr.js";import"./index-D5lFlNIX.js";import"./index-DVF2XGCm.js";const $=t=>{let o;const n=new Set,s=(d,i)=>{const v=typeof d=="function"?d(o):d;if(!Object.is(v,o)){const p=o;o=i??(typeof v!="object"||v===null)?v:Object.assign({},o,v),n.forEach(f=>f(o,p))}},r=()=>o,l={setState:s,getState:r,getInitialState:()=>h,subscribe:d=>(n.add(d),()=>n.delete(d))},h=o=t(s,r,l);return l},K=t=>$,X=t=>t;function z(t,o=X){const n=T.useSyncExternalStore(t.subscribe,()=>o(t.getState()),()=>o(t.getInitialState()));return T.useDebugValue(n),n}const G={BASE_URL:"./",DEV:!1,MODE:"production",PROD:!0,SSR:!1,STORYBOOK:"true"},E=new Map,_=t=>{const o=E.get(t);return o?Object.fromEntries(Object.entries(o.stores).map(([n,s])=>[n,s.getState()])):{}},W=(t,o,n)=>{if(t===void 0)return{type:"untracked",connection:o.connect(n)};const s=E.get(n.name);if(s)return{type:"tracked",store:t,...s};const r={connection:o.connect(n),stores:{}};return E.set(n.name,r),{type:"tracked",store:t,...r}},Y=(t,o={})=>(n,s,r)=>{const{enabled:c,anonymousActionType:y,store:l,...h}=o;let d;try{d=(c??(G?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!d)return t(n,s,r);const{connection:i,...v}=W(l,d,h);let p=!0;r.setState=(e,m,u)=>{const a=n(e,m);if(!p)return a;const S=u===void 0?{type:y||"anonymous"}:typeof u=="string"?{type:u}:u;return l===void 0?(i==null||i.send(S,s()),a):(i==null||i.send({...S,type:`${l}/${S.type}`},{..._(h.name),[l]:r.getState()}),a)};const f=(...e)=>{const m=p;p=!1,n(...e),p=m},b=t(r.setState,s,r);if(v.type==="untracked"?i==null||i.init(b):(v.stores[v.store]=r,i==null||i.init(Object.fromEntries(Object.entries(v.stores).map(([e,m])=>[e,e===v.store?b:m.getState()])))),r.dispatchFromDevtools&&typeof r.dispatch=="function"){const e=r.dispatch;r.dispatch=(...m)=>{e(...m)}}return i.subscribe(e=>{var m;switch(e.type){case"ACTION":if(typeof e.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return O(e.payload,u=>{if(u.type==="__setState"){if(l===void 0){f(u.state);return}Object.keys(u.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const a=u.state[l];if(a==null)return;JSON.stringify(r.getState())!==JSON.stringify(a)&&f(a);return}r.dispatchFromDevtools&&typeof r.dispatch=="function"&&r.dispatch(u)});case"DISPATCH":switch(e.payload.type){case"RESET":return f(b),l===void 0?i==null?void 0:i.init(r.getState()):i==null?void 0:i.init(_(h.name));case"COMMIT":if(l===void 0){i==null||i.init(r.getState());return}return i==null?void 0:i.init(_(h.name));case"ROLLBACK":return O(e.state,u=>{if(l===void 0){f(u),i==null||i.init(r.getState());return}f(u[l]),i==null||i.init(_(h.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return O(e.state,u=>{if(l===void 0){f(u);return}JSON.stringify(r.getState())!==JSON.stringify(u[l])&&f(u[l])});case"IMPORT_STATE":{const{nextLiftedState:u}=e.payload,a=(m=u.computedStates.slice(-1)[0])==null?void 0:m.state;if(!a)return;f(l===void 0?a:a[l]),i==null||i.send(null,u);return}case"PAUSE_RECORDING":return p=!p}return}}),b},q=Y,O=(t,o)=>{let n;try{n=JSON.parse(t)}catch(s){console.error("[zustand devtools middleware] Could not parse the received json",s)}n!==void 0&&o(n)};function Q(t,o){let n;try{n=t()}catch{return}return{getItem:r=>{var c;const y=h=>h===null?null:JSON.parse(h,void 0),l=(c=n.getItem(r))!=null?c:null;return l instanceof Promise?l.then(y):y(l)},setItem:(r,c)=>n.setItem(r,JSON.stringify(c,void 0)),removeItem:r=>n.removeItem(r)}}const w=t=>o=>{try{const n=t(o);return n instanceof Promise?n:{then(s){return w(s)(n)},catch(s){return this}}}catch(n){return{then(s){return this},catch(s){return w(s)(n)}}}},Z=(t,o)=>(n,s,r)=>{let c={storage:Q(()=>localStorage),partialize:e=>e,version:0,merge:(e,m)=>({...m,...e}),...o},y=!1;const l=new Set,h=new Set;let d=c.storage;if(!d)return t((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${c.name}', the given storage is currently unavailable.`),n(...e)},s,r);const i=()=>{const e=c.partialize({...s()});return d.setItem(c.name,{state:e,version:c.version})},v=r.setState;r.setState=(e,m)=>{v(e,m),i()};const p=t((...e)=>{n(...e),i()},s,r);r.getInitialState=()=>p;let f;const b=()=>{var e,m;if(!d)return;y=!1,l.forEach(a=>{var S;return a((S=s())!=null?S:p)});const u=((m=c.onRehydrateStorage)==null?void 0:m.call(c,(e=s())!=null?e:p))||void 0;return w(d.getItem.bind(d))(c.name).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==c.version){if(c.migrate){const S=c.migrate(a.state,a.version);return S instanceof Promise?S.then(I=>[!0,I]):[!0,S]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,a.state];return[!1,void 0]}).then(a=>{var S;const[I,L]=a;if(f=c.merge(L,(S=s())!=null?S:p),n(f,!0),I)return i()}).then(()=>{u==null||u(f,void 0),f=s(),y=!0,h.forEach(a=>a(f))}).catch(a=>{u==null||u(void 0,a)})};return r.persist={setOptions:e=>{c={...c,...e},e.storage&&(d=e.storage)},clearStorage:()=>{d==null||d.removeItem(c.name)},getOptions:()=>c,rehydrate:()=>b(),hasHydrated:()=>y,onHydrate:e=>(l.add(e),()=>{l.delete(e)}),onFinishHydration:e=>(h.add(e),()=>{h.delete(e)})},c.skipHydration||b(),f||p},V=Z,tt=t=>({session:null,setSession:o=>t({session:o},!1,"setSession"),resetSession:()=>t({session:null},!1,"resetSession")}),et=V(tt,{name:"session"}),nt=q(et,{name:"Session Service"}),R=K()(nt);function rt(t){return z(R,t)}function ot(){const t=rt(o=>!!o.session);return g.jsxs("header",{className:"flex justify-between border-b border-b-border px-8 py-4",children:[g.jsx("nav",{children:g.jsxs("div",{className:"flex items-center gap-x-8",children:[g.jsx(j,{href:"/","aria-label":"홈으로 이동",children:g.jsx(A,{className:"invert",src:"/vercel.svg",alt:"로고",width:32,height:32})}),g.jsx("ul",{className:"flex list-none items-center gap-x-8",children:[{href:"/",text:"홈"},{href:"/recipes",text:"레시피"},{href:"/milfap",text:"밀프랩"},{href:"/recipes/disease",text:"질환별 식단"}].map(({href:o,text:n})=>g.jsx("li",{children:g.jsx(st,{href:o,children:n})},o))})]})}),g.jsx("div",{children:g.jsx(F,{asChild:!0,children:g.jsx(j,{href:t?"/auth/logout":"/auth/login",children:t?"로그아웃":"로그인"})})})]})}function st({href:t,children:o}){const s=P().pathname===t;return g.jsx(j,{href:t,className:M("px-1","text-sm font-medium","transition-colors","border-b-2 border-transparent",{"border-b-foreground text-foreground":s,"text-muted-foreground hover:border-b-foreground hover:text-foreground":!s}),"aria-current":s?"page":void 0,children:o})}const yt={title:"widgets/Header",component:ot,parameters:{layout:"fullscreen",nextjs:{router:{pathname:"/recipes"}}},tags:["autodocs"]},x={beforeEach:()=>{B().push.mockImplementation(t=>{t==="/auth/login"?R.setState({session:{email:"test@test.com",name:"test"}}):t==="/auth/logout"&&R.setState({session:null})})},play:async({canvasElement:t})=>{const n=H(t).getByRole("banner");await U(n).toBeInTheDocument()}};var N,D,C,k,J;x.parameters={...x.parameters,docs:{...(N=x.parameters)==null?void 0:N.docs,source:{originalSource:`{
  beforeEach: () => {
    getRouter().push.mockImplementation(href => {
      if (href === '/auth/login') {
        sessionStore.setState({
          session: {
            email: 'test@test.com',
            name: 'test'
          }
        });
      } else if (href === '/auth/logout') {
        sessionStore.setState({
          session: null
        });
      }
    });
  },
  play: async ({
    canvasElement
  }) => {
    const canvas = within(canvasElement);
    const header = canvas.getByRole('banner');
    await expect(header).toBeInTheDocument();
  }
}`,...(C=(D=x.parameters)==null?void 0:D.docs)==null?void 0:C.source},description:{story:`기본 헤더 컴포넌트입니다.<br />
로그인하지 않은 상태에서는 로그인 버튼이 표시됩니다.`,...(J=(k=x.parameters)==null?void 0:k.docs)==null?void 0:J.description}}};const bt=["Default"];export{x as Default,bt as __namedExportsOrder,yt as default};
